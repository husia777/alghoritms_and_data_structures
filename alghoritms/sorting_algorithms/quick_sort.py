from random import randint, choice
######################################################################################################################3
#                           Быстрая сортировка
# Этот алгоритм также относится к алгоритмам «разделяй и властвуй».
# Его используют чаще других алгоритмов, описанных в этой статье.
# При правильной конфигурации он чрезвычайно эффективен и не требует дополнительной памяти,
# в отличие от сортировки слиянием.
# Массив разделяется на две части по разные стороны от опорного элемента.
# В процессе сортировки элементы меньше опорного помещаются перед ним, а равные или большие —позади.
#                               Алгоритм
# Быстрая сортировка начинается с разбиения списка и выбора одного из элементов в качестве опорного.
# А всё остальное передвигаем так, чтобы этот элемент встал на своё место.
# Все элементы меньше него перемещаются влево, а равные и большие элементы перемещаются вправо.
                # Время выполнения
# В среднем время выполнения быстрой сортировки составляет O(n log n).

# Обратите внимание, что алгоритм быстрой сортировки будет работать медленно,
# если опорный элемент равен наименьшему или наибольшему элементам списка.
# При таких условиях, в отличие от сортировок кучей и слиянием,
# обе из которых имеют в худшем случае время сортировки O(n log n),
# быстрая сортировка в худшем случае будет выполняться O(n²).






######################################################################################################################3

# формируем несортированный список
N = 5
a = []
for i in range(N):
    a.append(randint(0, 99))
print(a)

# Быстрая сортировка неоптимальный вариант
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    avg = choice(arr)
    left = [i for i in arr if i < avg]
    right = [i for i in arr if i > avg]
    middle = [i for i in arr if i == avg]
    return quick_sort(left) + middle + quick_sort(right)


def optimal_quick_sort(arr, fst, lst):
    if fst >= lst: #если индекс начального элемента больше либо равен индексу конечного программа завершается(отсортировали все элементы)
        return
    i, j = fst, lst  # начальный и конечный элемент нашего списка
    pivot = arr[(fst + lst) // 2]    #  опорный элемент равен элементу находящемуся по середине
    while i <= j: # пока начальный индекс меньше либо равно конечному
        while a[i] < pivot: #если первый элемент  меньше опорного элемента
            i += 1 # берем следующий и так пока условие истинно
        while a[j] > pivot: #если последний элемент  больше опорного элемента
            j -= 1 #берем предыдущий и так пока условие истинно
        if i <= j: # если начальный индекс меньше либо равен конеченому
            a[i], a[j] = a[j], a[i] #меняем их местами
            i, j = i + 1, j - 1 # начальный индекс увеличиваем на 1 а конечный уменьшаем на 1
    optimal_quick_sort(arr, fst, j) #рекурсивно вызываем нашу функцию
    optimal_quick_sort(arr, i, lst) #


print(quick_sort(a))
optimal_quick_sort(a, 0, len(a) - 1)
print(a)
